[
  {
    "objectID": "geommetry.html",
    "href": "geommetry.html",
    "title": "2  Geometría de bismuto",
    "section": "",
    "text": "El bismuto (Bi) es un elemento químico cuyo arreglo cristalino consiste de una celda unitaria romboédrica que contiene dos átomos , cada uno de ellos con tres primeros vecinos y tres segundos vecinos , como se señala en la Fig. (RomboRealRec?) a).\n\n\n\na) Celda romboédrica de bismuto en el espacio real, con los vectores de red \\(\\mathbf{a}^r_n\\) (\\(n=1,2,3\\)). b) Primera zona de Brillouin de la estructura romboédrica del Bi, con los vectores \\(\\mathbf{b}^r_n\\) y los puntos de alta simetría (naranja).\n\n\nLa estructura romboédrica de bismuto se esquematiza en la Fig. (RomboRealRec-Bi?) (a), donde los vectores de la red en el espacio real son:\n\\[\n    \\mathbf{a}_1^r = \\left ( -\\frac{1}{2}a , -\\frac{\\sqrt{3}}{6}a , \\frac{1}{3}c \\right ) \\hspace{10mm}\n    \\mathbf{a}_2^r = \\left (  \\frac{1}{2}a , -\\frac{\\sqrt{3}}{6}a , \\frac{1}{3}c \\right ) \\hspace{10mm}\n    \\mathbf{a}_3^r = \\left (             0 , -\\frac{\\sqrt{3}}{3}a , \\frac{1}{3}c \\right )\n\\]\nsiendo \\(a=4.5332\\) Å , \\(c= 11.7967\\) Å y \\(\\alpha = 57^{\\circ}19'\\) .\nEl grupo espacial de la estructura cristalina es \\(R\\bar{3}m\\) y su grupo puntual es el \\(D_{3d}\\). Por lo tanto, las operaciones de simetría espacial que caracterizan este arreglo cristalino son :\n\nla identidad (\\(\\hat{E}\\)),\nla inversión (\\(\\hat{I}\\)),\nlas rotaciones de 120\\(^{\\circ}\\) (\\(\\hat{C}_3\\)) respecto el eje \\(z\\) y 180\\(^{\\circ}\\) (\\(\\hat{C}_2\\)) respecto el eje \\(y\\) y\nlos planos de reflexión \\(\\mathcal{M}_a\\), \\(\\mathcal{M}_b\\) y \\(\\mathcal{M}_c\\), perpendiculares al eje de rotación \\(\\hat{C}_2\\).\n\n\n\n\nLa primera zona de Brillouin (1ZB) para la celda romboédrica tiene la forma de una octaedro truncado, el cual se esquematiza en la Fig. @:RomboRealRec b). Los vectores de la red recíproca son:\n\\[\n    \\mathbf{b}_1^r = \\left ( -1 , - \\frac{\\sqrt{3}}{3} , b \\right )g  \\hspace{15mm}\n    \\mathbf{b}_2^r = \\left (  1 , - \\frac{\\sqrt{3}}{3} , b \\right )g  \\hspace{15mm}\n    \\mathbf{b}_3^r = \\left (  0 , -2\\frac{\\sqrt{3}}{3} , b \\right )g  \n\\]\ndonde \\(b= a/c\\) y \\(g=1.3861\\) Å \\(^{-1}\\). Las coordenadas relativas de algunos puntos de alta simetría en esta 1ZB son:\n\\[\n    \\Gamma = \\left ( 0,0,0 \\right )\n\\] \\[\n    \\mathrm{K} = \\left [ 0,\\left (\\frac{3}{4}-\\frac{1}{2} h \\right ), \\left ( \\frac{1}{2} h +\\frac{1}{4} \\right ) \\right ]\n\\] \\[\n    \\mathrm{X} = \\left ( 0,\\frac{1}{2},\\frac{1}{2} \\right )\n\\] \\[\n    \\mathrm{W} = \\left ( h,1-h,\\frac{1}{2} \\right )\n\\] \\[\n    \\mathrm{T} = \\left ( \\frac{1}{2},\\frac{1}{2},\\frac{1}{2} \\right )\n\\] \\[\n    \\mathrm{L} = \\left ( 0,\\frac{1}{2},0 \\right )\n\\] \\[\n    \\Lambda = \\left ( 0,0,0 \\right )\n\\]\ndonde \\(h=0.2303\\) en el caso de bismuto .\n\n\n\nAl proyectar en el plano (111), el bulto del cristal forma una red hexagonal con dos átomos por celda unitaria.\nEn el modelo topológico de bismuto que reproduce los estados conductores de borde en una nanoestructura (ver Sección 3), se considera una estructura como la que se esquematiza en la Fig. (HexRealRec?).\n\n\n\na) Estructura de la celda unitaria para el Hamiltoniano topológico de bismuto en el espacio real y b) recíproco. Los vectores de la red real están etiquetados por \\(\\mathbf{a}^h_n\\) y los de la red recíproca por \\(\\mathbf{b}^h_n\\) (\\(n=1,2,3\\)).\n\n\nEste sistema consiste de una red hexagonal simple que preserva las simetrías espaciales de la red de bismuto. Los vectores de esta red hexagonal en el espacio real son:\n\\[\n\\begin{align}\n    \\mathbf{a}_1^h = \\left (a,0,0 \\right ) \\hspace{10mm}\n    \\mathbf{a}_2^h = \\left ( -\\frac{1}{2}a , \\frac{\\sqrt{3}}{2}a , 0 \\right ) \\hspace{10mm}\n    \\mathbf{a}_3^h = \\left (             0 , 0,c \\right )\n\\end{align}\n\\]\nLa 1ZB en el espacio recíproco también consiste de una celda hexagonal. Además, las coordenadas relativas de algunos de los puntos de alta simetría en ella son:\n\\[    \n\\Gamma = \\left ( 0,0,0 \\right )\n\\] \\[\n    \\mathrm{M} = \\left ( \\frac{1}{2},0,0 \\right )\n\\] \\[\n    \\mathrm{K} = \\left ( \\frac{1}{3},\\frac{1}{3},0 \\right )\n\\] \\[\n    \\mathrm{A} = \\left ( 0,0, \\frac{1}{2} \\right )\n\\] \\[\n    \\mathrm{L} = \\left ( \\frac{1}{2},0,\\frac{1}{2} \\right )\n\\] \\[\n    \\mathrm{H} = \\left ( \\frac{1}{3},\\frac{1}{3},\\frac{1}{2} \\right ).\n\\]"
  },
  {
    "objectID": "transp.html",
    "href": "transp.html",
    "title": "4  Transporte electrónico de bismuto",
    "section": "",
    "text": "Los cálculos de transporte electrónico en bismuto a bajas energías se realizaron utilizando el \\(H_{\\rm TB}^{Schin} (\\bk)\\). Con los parámetros de salto de este Hamiltoniano se construyó la geometría mostrada en la Figura~\\(\\ref{fig:bi-contacts}\\) en la paquetería KWANT , la cual consiste de una base hexagonal con 18 sitios a lo largo de un lado. Se evaluó el transporte electrónico con los 2 contactos conectados a la nanoestructura de bismuto, utilizando el formalismo de Landauer-B\"uttiker revisado en el capítulo \\(\\ref{chapter:transport}\\). En dicho formalismo, la cantidad clave a calcular es la probabilidad de transmisión, la cual se evaluó utilizando el método de la matriz de dispersión implementado en esta librería."
  },
  {
    "objectID": "transp.html#implementación-en-kwant",
    "href": "transp.html#implementación-en-kwant",
    "title": "4  Transporte electrónico de bismuto",
    "section": "4.1 Implementación en KWANT",
    "text": "4.1 Implementación en KWANT\n\nfrom pylab import *\nfrom pythtb import *\nimport kwant\n\n\ndef make_syst_Schindler(s,height):\n    alat  = 1\n\n    a1 = alat*[   1,        0,0]\n    a2 = alat*[-1/2,sqrt(3)/2,0]\n    a3 = alat*[   0,        0,1]\n\n    bismuth = kwant.lattice.general( [(a1),(a2),(a3)], \n                                 [(0,0,0),(0,0,0),(0,0,0),(0,0,0),(0,0,0),(0,0,0),(0,0,0),(0,0,0)],\n                                  norbs=1 )\n                \n    a,b,c,d,e,f,g,h = bismuth.sublattices\n\n    def hexagon_1(pos):\n        x, y, z = pos \n        return (-s<x<=-(s/2) and -np.sqrt(3)*(s+x-0.6)<y<np.sqrt(3)*(s+x-0.6) and 0 <= z <= height)\n    #cuadrado en el centro\n    def hexagon_2(pos):\n        x, y, z = pos \n        return (-s/2<x<=s/2 and -np.sqrt(3)*(s/2)+0.5<y<np.sqrt(3)*(s/2) and 0 <= z <= height)\n    #triangulo derecho \n    def hexagon_3(pos):\n        x, y, z = pos \n        return (s/2<x<=s and np.sqrt(3)*(x-s+0.1)<y<np.sqrt(3)*(s-x) and 0 <= z <= height)\n    #hexagono completo \n    def hexagon(pos):\n        x,y,z = pos \n        return (hexagon_1(pos)+hexagon_2(pos)+hexagon_3(pos))\n\n    #triangulo izquierdo\n    def hexagonL_1(pos):\n        x, y, z = pos \n        return (-s<x<=-(s/2) and -np.sqrt(3)*(s+x-0.6)<y<np.sqrt(3)*(s+x-0.6))\n    #cuadrado en el centro\n    def hexagonL_2(pos):\n        x, y, z = pos \n        return (-s/2<x<=s/2 and -np.sqrt(3)*(s/2)+0.5<y<np.sqrt(3)*(s/2))\n    #triangulo derecho \n    def hexagonL_3(pos):\n        x, y, z = pos \n        return (s/2<x<=s and np.sqrt(3)*(x-s+0.1)<y<np.sqrt(3)*(s-x))\n    #hexagono del lead completo\n    def hexagon_lead(pos):\n        x,y,z = pos \n        return (hexagonL_1(pos)+hexagonL_2(pos)+hexagonL_3(pos))\n\n    def onsite(site):\n        ϵ = 0.1; mI  = 2; mII = 2\n        if site.family   == a:\n            return ϵ+mI\n        elif site.family == b:\n            return ϵ+mI\n        elif site.family == c:\n            return ϵ-mI\n        elif site.family == d:\n            return ϵ-mI\n        elif site.family == e:\n            return -ϵ+mII  \n        elif site.family == f:\n            return -ϵ+mII  \n        elif site.family == g:\n            return -ϵ-mII  \n        elif site.family == h:\n            return -ϵ-mII  \n\n    syst = kwant.Builder()\n    syst[bismuth.shape(hexagon,(0,0,0))] = onsite  \n\n\n    sym0 = kwant.TranslationalSymmetry(bismuth.vec((0, 0, -1)))\n    lead0 = kwant.Builder(sym0)\n    lead0[bismuth.shape(hexagon_lead, (0, 0, 0))] = onsite\n\n    sym1 = kwant.TranslationalSymmetry(bismuth.vec((0, 0, 1)))\n    lead1 = kwant.Builder(sym1)\n    lead1[bismuth.shape(hexagon_lead, (0, 0, 0))] = onsite\n    \n    with open('hopps_kwant_Schindler.txt', \"rb\") as source_file:\n        code = compile(source_file.read(), 'hopps_kwant_Schindler.txt', \"exec\")\n        exec(code)\n    \n    leads = [lead0, lead1]   \n    syst.attach_lead(lead0)   \n    syst.attach_lead(lead1)   \n    syst = syst.finalized() \n    \n    return syst, leads    \n\n\ndef Conductancia(syst,energias,s,height):\n  datos = []\n  for energia in energias:\n    matrizS = kwant.smatrix(syst,energia)\n    datos.append(matrizS.transmission(0,1))\n  \n  return energias,datos\n\n\ns = 3\nheight = 5\n\nsyst, leads = make_syst_Schindler(s,height)\n\nenergias = linspace(-0.5,0.5)\n\nenergias,datos = Conductancia(syst,energias,s,height)"
  },
  {
    "objectID": "hamiltonian.html",
    "href": "hamiltonian.html",
    "title": "3  Hamiltoniano de amarre fuerte de bismuto",
    "section": "",
    "text": "\\[\n\\newcommand{\\bk}{\\boldsymbol{k}}\n\\newcommand{\\baI}{\\boldsymbol{a}_1}\n\\newcommand{\\baII}{\\boldsymbol{a}_2}\n\\newcommand{\\baIII}{\\boldsymbol{a}_3}\n\\]\nEn el año 2018, Schindler y colaboradores calcularon la estructura electrónica a primeros principios del bulto de bismuto y obtuvieron una brecha energética directa entre la banda de conducción y la de valencia en cada punto del espacio \\(\\bk\\). Debido a la presencia de esta brecha, pudieron analizar la estructura electrónica del bismuto en el esquema de la Química Cuántica Topológica (la cual se basa en el paradigma de la Representación de Bandas ), y confirmaron el carácter de aislante topológico de orden superior (HOTI) de este material. Finalmente, propusieron un Hamiltoniano de amarre fuerte topológicamente equivalente a un modelo realista de bismuto que facilita la identificación de los estados de borde pues no contienen los estados del bulto semimetálico. Además, al únicamente considerar 8 orbitales por celda unitaria, las simulaciones de sistemas tridimensionales grandes son computacionalmente realizables."
  },
  {
    "objectID": "hamiltonian.html#expresión-analítica",
    "href": "hamiltonian.html#expresión-analítica",
    "title": "3  Hamiltoniano de amarre fuerte de bismuto",
    "section": "3.1 Expresión analítica",
    "text": "3.1 Expresión analítica\nEl modelo del Hamiltoniano de 8 bandas de amarre fuerte del bismuto propuesto por Schindler y colaboradores es:\n\\[\n\\begin{align}\n    H_{\\rm TB}^{Schin}(\\bk) =\n    \\begin{pmatrix}\n    H_{TB,I} (\\bk) + \\epsilon I & \\delta M_{TB} (\\bk)\\\\\n    \\delta M_{TB} (\\bk)^\\dagger & H_{TB,II} (\\bk) - \\epsilon I\n    \\end{pmatrix}\n\\end{align}\n\\]\ndonde los términos de \\(H_{TB,I} (\\bk)\\), \\(H_{TB,II} (\\bk)\\) y \\(M_{TB} (\\bk)\\) tienen la forma:\n\\[\n\\begin{align}\n    H_{TB,I} (\\bk) &=\n    \\Gamma_1 \\lbrace m_I(1+ \\cos{\\bk \\cdot \\baIII^h}) - t_I[\\cos{\\bk \\cdot \\baI^h} + \\cos{\\bk \\cdot \\baII^h} + \\cos{\\bk \\cdot (\\baI^h + \\baII^h)}] \\rbrace \\nonumber \\\\\n    & + \\lambda_I [\\Gamma_2 \\sin{\\bk \\cdot \\baI^h} + \\Gamma_{2,1}^{I,I} \\sin{\\bk \\cdot \\baII^h} + \\Gamma_{2,2}^{I,I} \\sin{\\bk \\cdot (\\baI^h+\\baII^h)} + \\Gamma_3 \\sin \\bk \\cdot \\baIII^h]\n\\end{align}\n\\]\n\\[\n\\begin{align}\n    H_{TB,II} (\\bk) &=\n    \\Gamma_1 \\lbrace m_{II}(1+ \\cos{\\bk \\cdot \\baIII^h}) - t_{II}[\\cos{\\bk \\cdot \\baI^h} + \\cos{\\bk \\cdot \\baII^h} + \\cos{\\bk \\cdot (\\baI^h + \\baII^h)}] \\rbrace \\nonumber \\\\\n    & + \\lambda_{II} [\\Gamma_2 \\sin{\\bk \\cdot \\baI^h} + \\Gamma_{2,1}^{II,II} \\sin{\\bk \\cdot \\baII^h} + \\Gamma_{2,2}^{II,II} \\sin{\\bk \\cdot (\\baI^h+\\baII^h)} + \\Gamma_3 \\sin \\bk \\cdot \\baIII^h]\n\\end{align}\n\\]\n\\[\n\\begin{align}\n    M_{TB} (\\bk) &=\n    \\Gamma_2 [\\sin{\\bk \\cdot \\baI^h} + \\sin{\\bk \\cdot (2\\baI^h+\\baII^h)}] + \\Gamma_{2,1}^{I,II}[\\sin{\\bk \\cdot \\baII^h} + \\sin{\\bk \\cdot (\\baII^h-\\baI^h)}] \\nonumber \\\\\n    &- \\Gamma_{2,2}^{I,II}[\\sin{\\bk \\cdot (\\baI^h+\\baII^h)}+\\sin{\\bk \\cdot (\\baI^h+2\\baII^h)}]  - i\\Gamma_5[\\cos \\bk \\cdot \\baI^h + \\cos{\\bk \\cdot (2\\baI^h+\\baII^h)}] \\nonumber \\\\\n    &-i\\Gamma_{5,1}^{I,II} [\\cos{\\bk \\cdot \\baII^h}+ \\cos{\\bk \\cdot (\\baII^h-\\baI^h)}] -i\\Gamma_{5,2}^{I,II}[\\cos {\\bk \\cdot (\\baI^h + \\baII^h)}+\\cos {\\bk \\cdot (\\baI^h + 2\\baII^h)}]\n\\end{align}\n\\]"
  },
  {
    "objectID": "hamiltonian.html#implementación-en-pythtb",
    "href": "hamiltonian.html#implementación-en-pythtb",
    "title": "3  Hamiltoniano de amarre fuerte de bismuto",
    "section": "3.2 Implementación en PythTB",
    "text": "3.2 Implementación en PythTB\n\nfrom pylab import *\nfrom pythtb import *\n\na1 = [   1,        0,0]\na2 = [-1/2,sqrt(3)/2,0]\na3 = [   0,        0,1]\n\nlat = [a1,a2,a3]\norb = [[0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2],\n       [0,0,1/2]]\n\ntI  = 1; tII = 1\nmI  = 2; mII = 2\nϵ = 0.1\nλI = 0.3; λII = 1\nƔII = 1\nδ = 0.3\n\nBismuto = tb_model(3,3,lat,orb)\n\n\n# [0,0]\nBismuto.set_hop( -tI/2,0,0,[ 1,0,0] ) # cell = [ 1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -tI/2,0,0,[ 0,1,0] ) # cell = [ 0,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -tI/2,0,0,[ 1,1,0] ) # cell = [ 1,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\nBismuto.set_hop(  mI/2,0,0,[ 0,0,1] ) # cell = [ 0,0,1] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\n\n# [0,2]\n\nBismuto.set_hop( -λI/2,0,2,[0,0, 1] ) # cell = [ 0,0,1] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  λI/2,0,2,[0,0,-1] ) # cell = [ 0,0,-1] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\n\n# [0,3]\nBismuto.set_hop(  λI/(2J),0,3,[ 1,0,0] ) # cell = [ 1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -λI/(2J),0,3,[-1,0,0] ) # cell = [-1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  λI/(2J)*exp(2J*pi/3),0,3,[ 0, 1,0] ) # cell = [ 0,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -λI/(2J)*exp(2J*pi/3),0,3,[ 0,-1,0] ) # cell = [ 0,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  λI/(2J)*exp(1J*pi/3),0,3,[ 1, 1,0] ) # cell = [ 1, 1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -λI/(2J)*exp(1J*pi/3),0,3,[-1,-1,0] ) # cell = [-1,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\n\n# [0,5]\nBismuto.set_hop(  1J*δ/2*exp(1J*pi/3),0,5,[ 0, 1,0] ) # cell = [ 0,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  1J*δ/2*exp(1J*pi/3),0,5,[ 0,-1,0] ) # cell = [0,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  1J*δ/2*exp(1J*pi/3),0,5,[-1, 1,0] ) # cell = [-1,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop(  1J*δ/2*exp(1J*pi/3),0,5,[ 1,-1,0] ) # cell = [1,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\nBismuto.set_hop( -1J*δ/2,0,5,[ 1, 0,0] ) # cell = [1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2,0,5,[-1, 0,0] ) # cell = [-1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2,0,5,[ 2, 1,0] ) # cell = [2,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2,0,5,[-2,-1,0]) # cell = [-2,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\nBismuto.set_hop( -1J*δ/2*exp(2J*pi/3),0,5,[ 1, 1,0] ) # cell = [1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2*exp(2J*pi/3),0,5,[-1,-1,0] ) # cell = [-1,0,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2*exp(2J*pi/3),0,5,[ 1, 2,0] ) # cell = [2,1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\nBismuto.set_hop( -1J*δ/2*exp(2J*pi/3),0,5,[-1,-2,0]) # cell = [-2,-1,0] -> e^{ik·[(cell)·(a1,a2,a3)]}\n\n\n# [0,7]\nBismuto.set_hop(  δ/2J,0,7,[ 1,0,0] ) \nBismuto.set_hop( -δ/2J,0,7,[-1,0,0] )\n\nBismuto.set_hop( -δ/2J*exp(1J*pi/3),0,7,[ 0, 1,0] ) \nBismuto.set_hop(  δ/2J*exp(1J*pi/3),0,7,[ 0,-1,0] ) \nBismuto.set_hop( -δ/2J*exp(1J*pi/3),0,7,[-1, 1,0] ) \nBismuto.set_hop(  δ/2J*exp(1J*pi/3),0,7,[ 1,-1,0] ) \n\nBismuto.set_hop(  δ/2J,0,7,[ 2, 1,0] ) \nBismuto.set_hop( -δ/2J,0,7,[-2,-1,0] )\n\nBismuto.set_hop( -δ/2J*exp(2J*pi/3),0,7,[ 1, 1,0] ) \nBismuto.set_hop(  δ/2J*exp(2J*pi/3),0,7,[-1,-1,0] ) \nBismuto.set_hop( -δ/2J*exp(2J*pi/3),0,7,[ 1, 2,0] ) \nBismuto.set_hop(  δ/2J*exp(2J*pi/3),0,7,[-1,-2,0] ) \n\n\n# [1,1]\nBismuto.set_hop( -tI/2,1,1,[  1, 0,0] ) \n#Bismuto.set_hop( -tI/2,1,1,[ -1, 0,0] ) \nBismuto.set_hop( -tI/2,1,1,[  0, 1,0] ) \n#Bismuto.set_hop( -tI/2,1,1,[  0,-1,0] ) \nBismuto.set_hop( -tI/2,1,1,[  1, 1,0] ) \n#Bismuto.set_hop( -tI/2,1,1,[ -1,-1,0] ) \n\nBismuto.set_hop( mI/2,1,1,[ 0,0, 1] ) \n#Bismuto.set_hop( mI/2,1,1,[ 0,0,-1] ) \n\n\n# [1,2]\nBismuto.set_hop(  λI/(2J),1,2,[ 1,0,0] ) \nBismuto.set_hop( -λI/(2J),1,2,[-1,0,0] ) \n\nBismuto.set_hop(  λI/(2J)*exp(-2J*pi/3),1,2,[0, 1,0] ) \nBismuto.set_hop( -λI/(2J)*exp(-2J*pi/3),1,2,[0,-1,0] ) \n\nBismuto.set_hop(  λI/(2J)*exp(-1J*pi/3),1,2,[ 1, 1,0] ) \nBismuto.set_hop( -λI/(2J)*exp(-1J*pi/3),1,2,[-1,-1,0] ) \n\n\n#[1,3]\nBismuto.set_hop( -λI/2,1,3,[ 0,0, 1] ) \nBismuto.set_hop(  λI/2,1,3,[ 0,0,-1] ) \n\n\n#[1,4]\nBismuto.set_hop(  1J*δ/2*exp(-1J*pi/3),1,4,[  0, 1,0] ) \nBismuto.set_hop(  1J*δ/2*exp(-1J*pi/3),1,4,[  0,-1,0] )\nBismuto.set_hop(  1J*δ/2*exp(-1J*pi/3),1,4,[ -1, 1,0] )  \nBismuto.set_hop(  1J*δ/2*exp(-1J*pi/3),1,4,[  1,-1,0] ) \n\nBismuto.set_hop( -1J*δ/2,1,4,[  1, 0,0] ) \nBismuto.set_hop( -1J*δ/2,1,4,[ -1, 0,0] )\nBismuto.set_hop( -1J*δ/2,1,4,[  2, 1,0] )  \nBismuto.set_hop( -1J*δ/2,1,4,[ -2,-1,0] ) \n\nBismuto.set_hop( -1J*δ/2*exp(-2J*pi/3),1,4,[  1, 1,0] ) \nBismuto.set_hop( -1J*δ/2*exp(-2J*pi/3),1,4,[ -1,-1,0] )\nBismuto.set_hop( -1J*δ/2*exp(-2J*pi/3),1,4,[  1, 2,0] )  \nBismuto.set_hop( -1J*δ/2*exp(-2J*pi/3),1,4,[ -1,-2,0] ) \n\n\n#[1,6]\nBismuto.set_hop(   δ/2J,1,6,[  1,0,0] ) \nBismuto.set_hop(  -δ/2J,1,6,[ -1,0,0] )\n\nBismuto.set_hop(  -δ/2J*exp(-1J*pi/3),1,6,[  0, 1,0] )  \nBismuto.set_hop(   δ/2J*exp(-1J*pi/3),1,6,[  0,-1,0] ) \nBismuto.set_hop(  -δ/2J*exp(-1J*pi/3),1,6,[ -1, 1,0] )  \nBismuto.set_hop(   δ/2J*exp(-1J*pi/3),1,6,[  1,-1,0] )\n\nBismuto.set_hop(   δ/2J,1,6,[  2, 1,0] ) \nBismuto.set_hop(  -δ/2J,1,6,[ -2,-1,0] )\n\nBismuto.set_hop(  -δ/2J*exp(-2J*pi/3),1,6,[  1, 1,0] )  \nBismuto.set_hop(   δ/2J*exp(-2J*pi/3),1,6,[ -1,-1,0] ) \nBismuto.set_hop(  -δ/2J*exp(-2J*pi/3),1,6,[  1, 2,0] )  \nBismuto.set_hop(   δ/2J*exp(-2J*pi/3),1,6,[ -1,-2,0] )\n\n\n#[2,2]\nBismuto.set_hop( tI/2,2,2,[  1,0,0] ) \n#Bismuto.set_hop( -tI/2,2,2,[ -1,0,0] ) \nBismuto.set_hop( tI/2,2,2,[ 0, 1,0] ) \n#Bismuto.set_hop( -tI/2,2,2,[ 0,-1,0] ) \nBismuto.set_hop( tI/2,2,2,[  1, 1,0] )\n#Bismuto.set_hop( -tI/2,2,2,[ -1,-1,0] ) \n\nBismuto.set_hop( -mI/2,2,2,[ 0,0, 1] ) \n#Bismuto.set_hop( -mI/2,2,2,[ 0,0,-1] ) \n\n\n#[2,5]\nBismuto.set_hop(   δ/2J,2,5,[  1,0,0] ) \nBismuto.set_hop(  -δ/2J,2,5,[ -1,0,0] ) \n\nBismuto.set_hop(  -δ/2J*exp(1J*pi/3),2,5,[  0, 1,0] ) \nBismuto.set_hop(   δ/2J*exp(1J*pi/3),2,5,[  0,-1,0] )\nBismuto.set_hop(  -δ/2J*exp(1J*pi/3),2,5,[ -1, 1,0] )\nBismuto.set_hop(   δ/2J*exp(1J*pi/3),2,5,[  1,-1,0] )\n\nBismuto.set_hop(   δ/2J,2,5,[  2, 1,0] ) \nBismuto.set_hop(  -δ/2J,2,5,[ -2,-1,0] ) \n\nBismuto.set_hop(  -δ/2J*exp(2J*pi/3),2,5,[  1, 1,0] ) \nBismuto.set_hop(   δ/2J*exp(2J*pi/3),2,5,[ -1,-1,0] )\nBismuto.set_hop(  -δ/2J*exp(2J*pi/3),2,5,[  1, 2,0] )\nBismuto.set_hop(   δ/2J*exp(2J*pi/3),2,5,[ -1,-2,0] )\n\n\n#[2,7]\n\nBismuto.set_hop(  -δ*1J/2*exp(1J*pi/3) ,2,7,[  0, 1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(1J*pi/3) ,2,7,[  0,-1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(1J*pi/3) ,2,7,[ -1, 1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(1J*pi/3) ,2,7,[  1,-1,0] )\n\nBismuto.set_hop(   δ*1J/2, 2,7,[  1, 0,0] )\nBismuto.set_hop(   δ*1J/2, 2,7,[ -1, 0,0] )\nBismuto.set_hop(   δ*1J/2, 2,7,[  2, 1,0] )\nBismuto.set_hop(   δ*1J/2, 2,7,[ -2,-1,0] ) \n\nBismuto.set_hop(   δ*1J/2*exp(2J*pi/3) ,2,7,[  1, 1,0] )\nBismuto.set_hop(   δ*1J/2*exp(2J*pi/3) ,2,7,[ -1,-1,0] )\nBismuto.set_hop(   δ*1J/2*exp(2J*pi/3) ,2,7,[  1, 2,0] )\nBismuto.set_hop(   δ*1J/2*exp(2J*pi/3) ,2,7,[ -1,-2,0] )\n\n\n#[3,4]\nBismuto.set_hop(   δ/2J,3,4,[  1,0,0] ) \nBismuto.set_hop(  -δ/2J,3,4,[ -1,0,0] ) \n\nBismuto.set_hop(  -δ/2J*exp(-1J*pi/3),3,4,[  0, 1,0] ) \nBismuto.set_hop(   δ/2J*exp(-1J*pi/3),3,4,[  0,-1,0] )\nBismuto.set_hop(  -δ/2J*exp(-1J*pi/3),3,4,[ -1, 1,0] )\nBismuto.set_hop(   δ/2J*exp(-1J*pi/3),3,4,[  1,-1,0] )\n\nBismuto.set_hop(   δ/2J,3,4,[  2, 1,0] ) \nBismuto.set_hop(  -δ/2J,3,4,[ -2,-1,0] ) \n\nBismuto.set_hop(  -δ/2J*exp(-2J*pi/3),3,4,[  1, 1,0] ) \nBismuto.set_hop(   δ/2J*exp(-2J*pi/3),3,4,[ -1,-1,0] )\nBismuto.set_hop(  -δ/2J*exp(-2J*pi/3),3,4,[  1, 2,0] )\nBismuto.set_hop(   δ/2J*exp(-2J*pi/3),3,4,[ -1,-2,0] )\n\n\n#[3,6]\n\nBismuto.set_hop(  -δ*1J/2*exp(-1J*pi/3) ,3,6,[  0, 1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(-1J*pi/3) ,3,6,[  0,-1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(-1J*pi/3) ,3,6,[ -1, 1,0] )\nBismuto.set_hop(  -δ*1J/2*exp(-1J*pi/3) ,3,6,[  1,-1,0] )\n\nBismuto.set_hop(   δ*1J/2, 3,6,[  1, 0,0] )\nBismuto.set_hop(   δ*1J/2, 3,6,[ -1, 0,0] )\nBismuto.set_hop(   δ*1J/2, 3,6,[  2, 1,0] )\nBismuto.set_hop(   δ*1J/2, 3,6,[ -2,-1,0] ) \n\nBismuto.set_hop(   δ*1J/2*exp(-2J*pi/3) ,3,6,[  1, 1,0] )\nBismuto.set_hop(   δ*1J/2*exp(-2J*pi/3) ,3,6,[ -1,-1,0] )\nBismuto.set_hop(   δ*1J/2*exp(-2J*pi/3) ,3,6,[  1, 2,0] )\nBismuto.set_hop(   δ*1J/2*exp(-2J*pi/3) ,3,6,[ -1,-2,0] )\n\n\n#[4,4]\nBismuto.set_hop( -tII/2,4,4,[ 1,0,0] ) \nBismuto.set_hop( -tII/2,4,4,[ 0,1,0] ) \nBismuto.set_hop( -tII/2,4,4,[ 1,1,0] ) \n \nBismuto.set_hop(  mII/2,4,4,[ 0,0,1] ) \n\n\n#[4,6]\nBismuto.set_hop( -λII/2,4,6,[ 0,0, 1] ) \nBismuto.set_hop(  λII/2,4,6,[ 0,0,-1] ) \n\n\n#[4,7]\nBismuto.set_hop(  λII/2J,4,7,[  1, 0,0] ) \nBismuto.set_hop( -λII/2J,4,7,[ -1, 0,0] )\nBismuto.set_hop(  λII/2J,4,7,[  0, 1,0] ) \nBismuto.set_hop( -λII/2J,4,7,[  0,-1,0] )\nBismuto.set_hop( -λII/2J,4,7,[  1, 1,0] ) \nBismuto.set_hop(  λII/2J,4,7,[ -1,-1,0] )\n\nBismuto.set_hop( -ƔII/2,4,7,[  1,-1,0] ) \nBismuto.set_hop(  ƔII/2,4,7,[ -1, 1,0] )\nBismuto.set_hop(  ƔII/2,4,7,[  2, 1,0] ) \nBismuto.set_hop( -ƔII/2,4,7,[ -2,-1,0] )\nBismuto.set_hop( -ƔII/2,4,7,[  1, 2,0] ) \nBismuto.set_hop(  ƔII/2,4,7,[ -1,-2,0] )\n\n\n#[5,5]\nBismuto.set_hop( -tII/2,5,5,[ 1,0,0] ) \nBismuto.set_hop( -tII/2,5,5,[ 0,1,0] ) \nBismuto.set_hop( -tII/2,5,5,[ 1,1,0] ) \n \nBismuto.set_hop(  mII/2,5,5,[ 0,0,1] ) \n\n\n#[5,6]\nBismuto.set_hop(  λII/2J,5,6,[  1, 0,0] ) \nBismuto.set_hop( -λII/2J,5,6,[ -1, 0,0] )\nBismuto.set_hop(  λII/2J,5,6,[  0, 1,0] ) \nBismuto.set_hop( -λII/2J,5,6,[  0,-1,0] )\nBismuto.set_hop( -λII/2J,5,6,[  1, 1,0] ) \nBismuto.set_hop(  λII/2J,5,6,[ -1,-1,0] )\n\nBismuto.set_hop(  ƔII/2,5,6,[  1,-1,0] ) \nBismuto.set_hop( -ƔII/2,5,6,[ -1, 1,0] )\nBismuto.set_hop( -ƔII/2,5,6,[  2, 1,0] ) \nBismuto.set_hop(  ƔII/2,5,6,[ -2,-1,0] )\nBismuto.set_hop(  ƔII/2,5,6,[  1, 2,0] ) \nBismuto.set_hop( -ƔII/2,5,6,[ -1,-2,0] )\n\n\n#[5,7]\nBismuto.set_hop( -λII/2,5,7,[ 0,0, 1] ) \nBismuto.set_hop(  λII/2,5,7,[ 0,0,-1] ) \n\n\n#[6,6]\nBismuto.set_hop(  tII/2,6,6,[ 1,0,0] ) \nBismuto.set_hop(  tII/2,6,6,[ 0,1,0] ) \nBismuto.set_hop(  tII/2,6,6,[ 1,1,0] ) \n \nBismuto.set_hop( -mII/2,6,6,[ 0,0,1] ) \n\n\n#[7,7]\nBismuto.set_hop(  tII/2,7,7,[ 1,0,0] ) \nBismuto.set_hop(  tII/2,7,7,[ 0,1,0] ) \nBismuto.set_hop(  tII/2,7,7,[ 1,1,0] ) \n \nBismuto.set_hop( -mII/2,7,7,[ 0,0,1] )\n\n\nBismuto.set_onsite( [ϵ+mI,ϵ+mI,ϵ-mI,ϵ-mI,-ϵ+mII,-ϵ+mII,-ϵ-mII,-ϵ-mII] )"
  }
]